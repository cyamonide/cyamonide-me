## Style and Semantics

- A program has precise meaning and effect.
- A model of a programing language provides a way of describing the meaning of a program
- Typically this is done informally, by examples
- With Racket, we can do better

## Spelling rules

- Identifiers are names of constants, parameters, and user-defined functions
- Made up of letters, numbers, hyphens, underscores, and a few symbols
- Symbols start with `'`

## Syntax and grammar

There are three problems we need to address
1. Syntax: the way we're allowed to say things.
	- "?is This Sentence Syntactically Correct"
2. Semantics: the meaning of what we say
	- "Trombones fly hungrily."
3. Ambiguity: valid sentences have exactly one meaning
	- "Sally was given a book by Joyce"

## Grammars

- to enforce syntax and avoid ambiguity, we can use _grammars_
- For example, an English sentence can be made up of a subject, verb, and object in that order

## Semantic model
- The second of our three problems we will solve rigorously with a semantic model
- A semantic model of a programming language provides a method of predicting the result of running any program

## Syntax and Semantics

- Remember stepping/substitution rules

An example:
```
(define x 3) (define y (+ x 1)) y
(define x 3) (define y (+ 3 1)) y
(define x 3) (define y 4) y
(define x 3) (define y 4) 4
```

## Substitution in cond expressions

Three rules:
- when the first expression is false
- when the first expression is true
- and when it is else

```
(cond [false exp] ...) => (cond ...)
(cond [true exp] ...) => exp.
(cond [else exp]) => exp
```

## Errors

A __syntax error__ occurs when a sentence cannot be interpreted using the grammar.  
A __runtime error__ occurs when an expression cannot be reduced to a value by application of our (still incomplete) evaluation rules.  

## Simplification for `and` and `or`

```
(and false ...) => false
(and true ...) => (and ...)
(and) => true

(or true ...) => true
(or false ...) => (or ...)
(or) => false
```

## Substitution rules (so far)

1. Apply functions when all arguments are values
2. When give na choice, evaluate the leftmost expression first
3. (f v1 ... vn) => v when f is built-in
	- substitutes the result of a built-in function directly
4. (f v1 ... vn) => exp when (define (f x1 ... xn) exp) occurs to the left

## Importance of the model

