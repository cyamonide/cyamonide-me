<h2>Administrivia</h2>

<p>A0 due today. <br />
A0 must be completed before A1.  </p>

<hr>

<h2>Notes</h2>

<p><strong>Canonical form:</strong> Easier for us to think about. <br />
When we extend this idea to programming, we'll find cases where orderings result in different values.  </p>

<p><strong>Two rules:</strong> <br />
- Functions are applied to values
- When there is a choice of possible substitutions, always take the leftmost choice.</p>

<p>$$
\begin{aligned}
    g(g(1,3), f(3))\
    &amp;= g (1+3, f(3)) \
    &amp;= g(4, f(3))\
    &amp;= g(4, 3^2)\
    &amp;= g(4, 9) = 4+9 \
\end{aligned}
$$</p>

<p>Now (using those two rules), for any expression, there is at most one choice of substitution. <br />
The computed final result is the same as for other choices.</p>

<h2>Use of parentheses</h2>

<h3>Ordering</h3>

<p>In arithmetic expressions, we often place operators between their operands. <br />
We have some rules (e.g. division before addition, left to right) to specify order of operations. This are our canonical rules. <br />
Sometimes, rules are not sufficient, and parentheses are required.  </p>

<h3>Functions</h3>

<p>We treat infix operators (+, -, etc) like functions; we don't need parentheses to specify order of operations. <br />
Also known as <em>Polish notation</em>.</p>

<p>For example, $(6-4)/(5+7)$ becomes $/(-(6,4), +(5,7))$.</p>

<p>Racket writes its functions differently: the function name moves inside the parentheses, and the commas are changed to spaces. <br />
For example, $g(2, 3)$ becomes <code>(g 2 3)</code>. This is a valid Racket expression once <code>g</code> is defined. <br />
Functions and mathematical operations are treated exactly the same way in Racket.  </p>

<h2>Racket expressions</h2>

<h3>Expressions in Racket</h3>

<p>Extra parentheses are harmless in arithmetic expressions. <br />
However, these are <strong>harmful</strong> in Racket expressions.</p>

<p>5 + 3 * (10 - 5)
(+ 5 (* 3 (- 10 5)))</p>

<h3>Evaluating a Racket expression</h3>

<p>We use a process of substitution, just as in our mathematical expressions. <br />
Each step is indicated using the 'yields' symbol $\implies$.</p>

<p><code>
(* (- 6 4) (+ 3 2))
=&gt; (* 2 (+ 3 2))
...
</code></p>

<h2>DrRacket</h2>

<h3>Numbers in DrRacket</h3>

<ul>
<li>Integers are unbounded</li>
<li>Rational numbers are represented exactly</li>
<li>Expressions whose values are not rational numbers are flagged as being <code>inexact</code> <br />
<ul>
<li>For example <code>(sqrt 2)</code> evaluates to <code>#i1.414213562370951</code></li>
<li>We will not use inexact numbers much (if at all)</li>
</ul></li>
</ul>

<h3>Built-in operators</h3>

<ul>
<li>Arithmetic operators <code>+ - * /</code></li>
<li>Constants <code>e pi</code></li>
<li>Functions <code>(abs x), (max x y ...), (ceiling x), (expt x y), (exp x), (cos x),</code> ...</li>
</ul>

<p>Assignment will tell you which functions you can/should and cannot use. <br />
Questions on implementation should go to tutor first, or Help Desk.</p>

<h3>Expressions causing errors</h3>

<p><code>(* (5) 3)</code> contains an unnecessary set of parentheses.</p>

<h3>Defining functions</h3>

<p>$g(x, y) = x + y$ <br />
<code>(define (g x y) (+ x y))</code>  </p>

<p><code>define</code> is a <em>special form</em> - looks like a Racket function, but not all of its arguments are evaluated.</p>

<p>Internally, Racket applies a substitution for user-defined functions. <br />
The substitution for <code>(g 3 5)</code> would be <code>(+ 3 5)</code>.  </p>

<p>Each parameter name has meaning <em>only within the body of its function</em>. <br />
Functions cannot have the same name.  </p>

<h3>Defining constants</h3>

<p><code>(define k 3)</code> <br />
<code>(define p (sqr k))</code> <br />
Assume that constants are evaluated top to bottom.  </p>
